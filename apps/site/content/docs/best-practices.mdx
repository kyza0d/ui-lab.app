---
title: "Best Practices"
description: "Learn how to effectively use and develop with UI Lab components following proven patterns and conventions."
category: "Development"
publishedOn: "2026-12-14"
tags: ["best-practices", "patterns", "development", "accessibility", "performance"]
---

# Best Practices & Development

This guide covers proven patterns, conventions, and best practices for using and developing UI Lab components effectively.

## Table of Contents

- [Component Usage](#component-usage) - Importing, props, variants, and events
- [Accessibility](#accessibility) - Keyboard navigation, screen readers, testing
- [Styling Components](#styling-components) - CSS variables, overrides, dark mode
- [Type Safety](#type-safety) - Prop types, discriminated unions, strict mode
- [Component Composition](#component-composition) - Compound components, wrappers
- [State Management](#state-management) - React hooks, React Aria, best practices
- [Performance Optimization](#performance-optimization) - Code splitting, memoization, bundle size
- [Testing](#testing) - Unit tests, interaction tests, accessibility tests
- [Development Workflow](#development-workflow) - Setup, testing changes, code style

---

---

## Component Usage

### Importing Components

Always import components from the main entry point:

```tsx
// ✅ Correct
import { Button, Input, Card } from 'ui-lab-components';

// ❌ Avoid
import Button from 'ui-lab-components/dist/button';
```

Components are tree-shakeable, so only used components are included in your bundle.

---

### Importing Styles

Import the global styles **once** in your application root:

```tsx
// app.tsx or main.tsx
import 'ui-lab-components/styles.css';
import App from './App';

export default function Root() {
  return <App />;
}
```

⚠️ **Important:** Import styles exactly once at the highest level. Importing multiple times has no effect but wastes bytes.

### Component Props

Use TypeScript to ensure correct prop usage:

```tsx
import { Button, type ButtonProps } from 'ui-lab-components';

interface MyButtonProps extends ButtonProps {
  label: string;
}

export function MyButton({ label, ...props }: MyButtonProps) {
  return <Button {...props}>{label}</Button>;
}
```

### Variants & Sizes

Use the `variant` and `size` props to customize appearance:

```tsx
// Variants: primary (default), secondary, tertiary, destructive
<Button variant="primary">Primary</Button>
<Button variant="secondary">Secondary</Button>
<Button variant="destructive">Delete</Button>

// Sizes: sm, md (default), lg
<Button size="sm">Small</Button>
<Button size="md">Medium</Button>
<Button size="lg">Large</Button>

// Combine
<Button variant="secondary" size="lg">
  Large Secondary
</Button>
```

### Event Handlers

Handle events with proper typing:

```tsx
const [count, setCount] = useState(0);

function handleClick(e: React.MouseEvent<HTMLButtonElement>) {
  setCount(count + 1);
}

<Button onClick={handleClick}>
  Clicked {count} times
</Button>
```

### Controlled vs Uncontrolled

**Uncontrolled components (recommended):**
```tsx
// Let the component manage its own state
<Input placeholder="Type here..." />
```

**Controlled components (when needed):**
```tsx
const [value, setValue] = useState('');

<Input
  value={value}
  onChange={(e) => setValue(e.currentTarget.value)}
/>
```

Use controlled components only when you need to monitor or manipulate the value in real-time.

---

---

## Accessibility

All UI Lab components are built with React Aria and provide WCAG 2.1 AA compliance out of the box.

### Keyboard Navigation

All interactive components support keyboard navigation:

- **Tab** – Move focus to next element
- **Shift+Tab** – Move focus to previous element
- **Enter/Space** – Activate buttons and toggles
- **Arrow Keys** – Navigate in lists, menus, sliders
- **Escape** – Close modals and popovers

No additional setup required – accessibility is built-in.

### Screen Reader Support

Components announce themselves correctly to screen readers:

```tsx
// Buttons announce their label
<Button>Save Document</Button>

// Form inputs need labels
<Label htmlFor="email">Email</Label>
<Input id="email" type="email" />

// Images should have alt text
import { Icon } from 'lucide-react';
<Icon aria-label="Loading..." />

// Use aria-description for additional context
<Input
  aria-label="Search"
  aria-description="Search for products, articles, or users"
/>
```

### Focus Management

Components manage focus automatically through React Aria:

```tsx
// When modal opens, focus moves inside automatically
<Modal open>
  {/* Focus is trapped in the modal */}
  <Input autoFocus /> {/* Focus moves here when modal opens */}
</Modal>

// When modal closes, focus returns to trigger
<Button onClick={() => setOpen(false)}>
  Close
</Button>
```

### Testing Accessibility

**Manual testing:**
1. Use keyboard only (no mouse) to navigate
2. Test with screen reader (NVDA on Windows, VoiceOver on Mac)
3. Test at 200% zoom
4. Test with Windows High Contrast mode

**Automated testing:**
Use @axe-core/react for automated checks:

```tsx
import { axe, toHaveNoViolations } from 'jest-axe';

test('Button is accessible', async () => {
  const { container } = render(<Button>Click</Button>);
  const results = await axe(container);
  expect(results).toHaveNoViolations();
});
```

### Common Accessibility Issues

❌ **Missing labels:**
```tsx
<Input placeholder="Email" />  // Bad – no label
```

✅ **Correct labels:**
```tsx
<Label htmlFor="email">Email</Label>
<Input id="email" />  // Good – associated label
```

❌ **Broken focus:**
```tsx
<div onClick={() => doSomething()}>
  Click me  // Bad – not keyboard accessible
</div>
```

✅ **Semantic buttons:**
```tsx
<Button onClick={() => doSomething()}>
  Click me  // Good – keyboard accessible
</Button>
```

❌ **Unlabeled icons:**
```tsx
<Button icon={<TrashIcon />} />  // Bad – not labeled
```

✅ **Labeled icons:**
```tsx
<Button icon={<TrashIcon />} aria-label="Delete item" />
// Good – screen readers know the purpose
```

---

## Styling Components

### Using CSS Variables for Theming

Keep components themable by using CSS variables:

```tsx
// ✅ Good – uses CSS variables
import styles from './Card.module.css';

export function Card({ children }: CardProps) {
  return <div className={styles.card}>{children}</div>;
}
```

```css
/* Card.module.css */
.card {
  background-color: var(--background-surface);
  border: 1px solid var(--color-background-border);
  border-radius: var(--radius-md);
  padding: var(--spacing-4);
}
```

Customize globally by changing CSS variables:
```css
:root {
  --radius-md: 0.5rem;     /* Larger radius */
  --spacing-4: 1.5rem;     /* More padding */
}
```

### Overriding Styles Safely

Extend component styles without modifying the original:

```tsx
import styles from './Button.module.css';
import buttonStyles from './CustomButton.module.css';

<Button className={buttonStyles.custom} />
```

```css
/* CustomButton.module.css */
.custom {
  @apply font-bold;
  /* Override specific properties */
  background: linear-gradient(135deg, var(--color-primary), var(--color-secondary));
}
```

### Tailwind Classes

Combine Tailwind utilities with UI Lab components:

```tsx
<div className="flex gap-4 md:gap-6">
  <Button className="flex-1">Save</Button>
  <Button variant="secondary" className="flex-1">
    Cancel
  </Button>
</div>
```

❌ **Don't use !important:**
```css
.button {
  background-color: red !important;  /* Bad – breaks customization */
}
```

### Dark Mode

Components automatically support dark mode through CSS variables:

```css
:root {
  --background-50: oklch(99.2% 0.001 240);   /* Light */
  --foreground-950: oklch(11.8% 0.018 240);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background-50: oklch(11.8% 0.018 240);  /* Dark */
    --foreground-950: oklch(99.2% 0.001 240);
  }
}
```

---

---

## Type Safety

### Prop Types

Always use TypeScript for component props:

```tsx
import { Button, type ButtonProps } from 'ui-lab-components';

interface Props extends ButtonProps {
  label: string;
  onSubmit?: () => Promise<void>;
}

export function SubmitButton({ label, onSubmit, ...props }: Props) {
  const [loading, setLoading] = useState(false);

  const handleClick = async () => {
    try {
      setLoading(true);
      await onSubmit?.();
    } catch (error) {
      console.error('Submit failed:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Button {...props} onClick={handleClick} disabled={loading}>
      {label}
    </Button>
  );
}
```

### Discriminated Unions

Use discriminated unions for type-safe variants:

```tsx
type ButtonProps =
  | { variant: 'primary'; icon?: React.ReactNode }
  | { variant: 'secondary'; size?: 'sm' | 'lg' };

// TypeScript ensures correct prop combinations
<Button variant="primary" icon={<Icon />} />
<Button variant="secondary" size="lg" />
```

### Strict Mode Benefits

Enable TypeScript strict mode for better type checking:

```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "noImplicitThis": true,
    "strictNullChecks": true
  }
}
```

This catches many bugs at compile time rather than runtime.

---

---

## Component Composition

### Compound Components

Build complex UIs by composing components:

```tsx
<Card>
  <Card.Header>
    <Card.Title>Settings</Card.Title>
  </Card.Header>
  <Card.Content>
    {/* Content here */}
  </Card.Content>
  <Card.Footer>
    <Button variant="secondary">Cancel</Button>
    <Button>Save</Button>
  </Card.Footer>
</Card>
```

### Composition Over Inheritance

Create new components by composing existing ones:

```tsx
// ✅ Good – composition
export function PrimaryButton(props: ButtonProps) {
  return <Button {...props} variant="primary" />;
}

// ❌ Avoid – trying to inherit
export class MyButton extends Button {
  // Custom logic
}
```

### Wrapper Components

Extend components with additional logic:

```tsx
import { Input, type InputProps } from 'ui-lab-components';

interface SearchInputProps extends InputProps {
  onSearch?: (query: string) => void;
}

export function SearchInput({ onSearch, ...props }: SearchInputProps) {
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    onSearch?.(e.currentTarget.value);
  };

  return (
    <Input
      {...props}
      type="search"
      onChange={handleChange}
      placeholder="Search..."
    />
  );
}
```

---

---

## State Management

### React Hooks

Use standard React hooks with UI Lab components:

```tsx
// useState for component state
const [isOpen, setIsOpen] = useState(false);

// useCallback for memoized callbacks
const handleClose = useCallback(() => {
  setIsOpen(false);
}, []);

// useEffect for side effects
useEffect(() => {
  console.log('Component mounted');
  return () => console.log('Component unmounting');
}, []);
```

### React Aria Hooks

Leverage React Aria hooks for complex interactions:

```tsx
import { useButton } from 'react-aria';
import { useToggleState } from 'react-stately';

export function MyToggle() {
  const state = useToggleState();
  const ref = useRef(null);
  const { buttonProps } = useButton({ onPress: () => state.toggle() }, ref);

  return (
    <button {...buttonProps} ref={ref}>
      {state.isSelected ? 'On' : 'Off'}
    </button>
  );
}
```

### Avoiding State Issues

❌ **Don't mutate state directly:**
```tsx
state.items.push(newItem);  // Bad
setState(state);
```

✅ **Create new references:**
```tsx
setState([...state.items, newItem]);  // Good
```

---

---

## Performance Optimization

### Code Splitting

Lazy load components that aren't immediately needed:

```tsx
import { lazy, Suspense } from 'react';

const Modal = lazy(() => import('./Modal'));
const HeavyComponent = lazy(() => import('./HeavyComponent'));

function App() {
  const [showModal, setShowModal] = useState(false);

  return (
    <>
      {showModal && (
        <Suspense fallback={<div>Loading...</div>}>
          <Modal onClose={() => setShowModal(false)} />
        </Suspense>
      )}
    </>
  );
}
```

### Memoization

Prevent unnecessary re-renders:

```tsx
import { memo, useMemo, useCallback } from 'react';

// Memoize entire component
const ExpensiveComponent = memo(function ExpensiveComponent({
  data,
}: Props) {
  return <div>{data.value}</div>;
});

// Memoize values
const memoizedValue = useMemo(() => {
  return expensiveCalculation(data);
}, [data]);

// Memoize callbacks
const memoizedCallback = useCallback(() => {
  doSomething();
}, [dependency]);
```

### Bundle Size

Import only what you use:

```tsx
// ✅ Tree-shakeable
import { Button, Input } from 'ui-lab-components';

// ❌ Imports everything
import * as UI from 'ui-lab-components';
```

---

---

## Testing

### Unit Testing

Test components in isolation:

```tsx
import { render, screen } from '@testing-library/react';
import { Button } from 'ui-lab-components';

test('Button renders with label', () => {
  render(<Button>Click me</Button>);
  expect(screen.getByRole('button', { name: 'Click me' })).toBeInTheDocument();
});
```

### Interaction Testing

Test user interactions:

```tsx
import userEvent from '@testing-library/user-event';

test('Button fires onClick when clicked', async () => {
  const handleClick = jest.fn();
  const user = userEvent.setup();

  render(<Button onClick={handleClick}>Click</Button>);
  await user.click(screen.getByRole('button'));

  expect(handleClick).toHaveBeenCalledTimes(1);
});
```

### Accessibility Testing

Test keyboard navigation and screen reader support:

```tsx
test('Button is keyboard accessible', async () => {
  const user = userEvent.setup();
  render(<Button>Click</Button>);

  // Tab to button
  await user.tab();

  // Press Enter to activate
  await user.keyboard('{Enter}');

  // Button should have been activated
});
```

---

## Development Workflow

### Setup

```bash
# Clone and install
git clone https://github.com/kyza0d/ui-lab.app.git
cd ui-lab/app
pnpm install

# Start development
pnpm dev

# Type checking
pnpm type-check
```

### Testing Changes

1. Make changes to component files
2. Hot reload works automatically
3. View changes at http://localhost:3000
4. Run `pnpm type-check` to verify TypeScript

### Code Style

- Use meaningful variable names
- Write self-documenting code
- Keep functions focused and pure
- Use TypeScript for type safety

---

## Summary

Key principles for working with UI Lab:

1. **Always import styles once** at app root
2. **Use TypeScript** for type safety
3. **Leverage React Aria** for accessibility – it's built-in
4. **Use CSS variables** for theming and customization
5. **Compose components** rather than creating complex hierarchies
6. **Test accessibility** – keyboard navigation and screen readers
7. **Memoize expensive operations** for performance
8. **Keep components simple** – let the library handle complexity

Following these practices will help you build accessible, performant, and maintainable applications with UI Lab.
