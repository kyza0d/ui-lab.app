import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface DiscoveredElement {
  folderName: string;
  importPath: string;
  id: string;
  variableName: string;
}

function discoverAllElements(): DiscoveredElement[] {
  const elementsPath = path.join(__dirname, '..', 'src', 'elements');

  if (!fs.existsSync(elementsPath)) {
    console.error(`Elements directory not found at ${elementsPath}`);
    process.exit(1);
  }

  const discovered: DiscoveredElement[] = [];
  const seenIds = new Set<string>();

  console.log('\nüîç Discovering elements...\n');

  function discoverInDirectory(dirPath: string, relativePath: string = '') {
    const folders = fs
      .readdirSync(dirPath)
      .filter(
        (f) =>
          fs.statSync(path.join(dirPath, f)).isDirectory() &&
          !f.startsWith('.')
      )
      .sort();

    for (const folderName of folders) {
      const elementPath = path.join(dirPath, folderName);
      const indexTsPath = path.join(elementPath, 'index.ts');
      const indexTsxPath = path.join(elementPath, 'index.tsx');
      const indexPath = fs.existsSync(indexTsPath) ? indexTsPath :
                        fs.existsSync(indexTsxPath) ? indexTsxPath : null;

      const variationsPath = path.join(elementPath, 'variations');
      const hasVariations = fs.existsSync(variationsPath);

      if (indexPath && hasVariations) {
        const variationFolders = fs
          .readdirSync(variationsPath)
          .filter((f) => /^\d{2}-/.test(f));

        if (variationFolders.length === 0) {
          console.error(`  ‚úó ${folderName}: No variations found in variations/`);
          process.exit(1);
        }

        const elementId = folderName.toLowerCase();
        if (seenIds.has(elementId)) {
          console.error(
            `  ‚úó Duplicate element ID "${elementId}" - elements must have unique IDs`
          );
          process.exit(1);
        }
        seenIds.add(elementId);

        const variableName = elementId.charAt(0).toLowerCase() + elementId.slice(1) + 'Element';
        const importPath = relativePath ? `${relativePath}/${folderName}` : folderName;

        discovered.push({
          folderName,
          importPath,
          id: elementId,
          variableName,
        });

        console.log(`  ‚úì ${importPath} (id: "${elementId}")`);
      } else if (!hasVariations) {
        const newRelativePath = relativePath ? `${relativePath}/${folderName}` : folderName;
        discoverInDirectory(elementPath, newRelativePath);
      }
    }
  }

  discoverInDirectory(elementsPath);

  if (discovered.length === 0) {
    console.error('  ‚úó No elements found');
    process.exit(1);
  }

  return discovered;
}

function generateIndexFile(elements: DiscoveredElement[]): string {
  // Sort alphabetically by import path for consistent output
  const sortedElements = elements.sort((a, b) =>
    a.importPath.localeCompare(b.importPath)
  );

  // Generate imports
  const imports = sortedElements
    .map((el) => `import ${el.variableName} from './${el.importPath}';`)
    .join('\n');

  // Generate registry entries
  const registryEntries = sortedElements
    .map((el) => `  [${el.variableName}.id]: ${el.variableName},`)
    .join('\n');

  return `// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// Generated by: scripts/generate-element-registry.ts
// To regenerate: pnpm generate
//
// To add a new element:
//   1. Create folder: src/elements/YourElement/
//   2. Create index.ts or index.tsx with metadata export
//   3. Create variations/ directory with variation folders
//   4. Add variations in variations/NN-name/ directories with index.tsx
//   5. Run: pnpm generate

import type { ElementRegistry } from '../types';

// Element imports (auto-generated)
${imports}

// Type exports (preserved)
export type { ElementMetadata, ElementVariant, ElementPackageMetadata } from '../types';
export type { ElementCategoryId, ElementCategoryDefinition } from './categories';

// Category exports (preserved)
export {
  elementCategories,
  elementCategoryMapping,
  getCategoryForElement,
  getCategoryDefinition,
  groupElementsByCategory,
  getElementsInCategory,
  getCategoriesWithElements,
} from './categories';

// Package exports
export {
  elementPackages,
  getPackageById,
  getAllPackages,
  getElementsInPackage,
  getPackageForElement,
} from './packages';

// Registry (auto-generated)
export const elementRegistry: ElementRegistry = {
${registryEntries}
};

// Helper functions (preserved)
export const elementsList = Object.values(elementRegistry);

export const getElementById = (id: string) => elementRegistry[id];

export const getElementsByCategory = (category: string) =>
  elementsList.filter((el) => el.category === category);

export const getElementsByTag = (tag: string) =>
  elementsList.filter((el) => el.tags.includes(tag));

export const searchElements = (query: string) => {
  const lowerQuery = query.toLowerCase();
  return elementsList.filter(
    (el) =>
      el.name.toLowerCase().includes(lowerQuery) ||
      el.description.toLowerCase().includes(lowerQuery) ||
      el.tags.some((tag) => tag.toLowerCase().includes(lowerQuery))
  );
};

export const getAllCategories = () => {
  const categories = new Set<string>();
  elementsList.forEach((el) => categories.add(el.category));
  return Array.from(categories).sort();
};

export const getAllTags = () => {
  const tags = new Set<string>();
  elementsList.forEach((el) => el.tags.forEach((tag) => tags.add(tag)));
  return Array.from(tags).sort();
};
`;
}

async function main() {
  try {
    const elements = discoverAllElements();

    console.log('\nüìù Generating element registry...\n');

    const indexPath = path.join(__dirname, '..', 'src', 'elements', 'index.ts');
    const content = generateIndexFile(elements);

    fs.writeFileSync(indexPath, content);
    console.log(`  ‚úì index.ts (${elements.length} elements)`);

    console.log('\n‚úÖ Element registry generation complete!\n');
  } catch (error) {
    console.error(
      '\n‚ùå Error during element registry generation:',
      error instanceof Error ? error.message : String(error)
    );
    process.exit(1);
  }
}

main();
