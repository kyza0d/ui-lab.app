import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface Variation {
  name: string;
  description: string;
  demoPath: string;
  exportName: string;
  files: any[];
}

function generateManifest(elementName: string): void {
  const elementPath = path.join(__dirname, '..', 'src', 'elements', elementName);
  const variationsPath = path.join(elementPath, 'variations.json');

  if (!fs.existsSync(variationsPath)) {
    console.error(`variations.json not found for ${elementName}`);
    return;
  }

  const variations: Record<string, Variation> = JSON.parse(
    fs.readFileSync(variationsPath, 'utf-8')
  );

  const demoPaths: Array<{ demoPath: string; variationKey: string; exportName: string }> = [];

  for (const [variationKey, variationMeta] of Object.entries(variations)) {
    const { demoPath, exportName } = variationMeta;
    demoPaths.push({ demoPath, variationKey, exportName });
  }

  const tsContent = `// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// Generated by: scripts/generate-manifest.ts
// To regenerate: pnpm generate

export const DEMO_PATH_MAP = {
${demoPaths.map((item) => `  '${item.demoPath}': { variationKey: '${item.variationKey}', exportName: '${item.exportName}' },`).join('\n')}
} as const;

export type DemoPaths = keyof typeof DEMO_PATH_MAP;
`;

  const outputPath = path.join(elementPath, 'manifest.ts');
  fs.writeFileSync(outputPath, tsContent);
}

async function main() {
  try {
    const elementsPath = path.join(__dirname, '..', 'src', 'elements');

    function findElements(dirPath: string, relativePath: string = ''): string[] {
      const results: string[] = [];
      const entries = fs.readdirSync(dirPath).filter(
        (f) => fs.statSync(path.join(dirPath, f)).isDirectory() && !f.startsWith('.')
      );
      for (const entry of entries) {
        const entryRelPath = relativePath ? `${relativePath}/${entry}` : entry;
        if (fs.existsSync(path.join(dirPath, entry, 'variations.json'))) {
          results.push(entryRelPath);
        } else {
          results.push(...findElements(path.join(dirPath, entry), entryRelPath));
        }
      }
      return results;
    }

    const elements = findElements(elementsPath).sort();

    console.log('\nüìã Generating manifest files...\n');

    for (const elementName of elements) {
      generateManifest(elementName);
      console.log(`  ‚úì ${elementName}/manifest.ts`);
    }

    console.log('\n‚úÖ Manifest generation complete!\n');
  } catch (error) {
    console.error(
      '\n‚ùå Error during manifest generation:',
      error instanceof Error ? error.message : String(error)
    );
    process.exit(1);
  }
}

main();
