// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// Generated by: scripts/generate-element-registry.ts
// To regenerate: pnpm generate
//
// To add a new element:
//   1. Create folder: src/elements/YourElement/
//   2. Create index.ts or index.tsx with metadata export
//   3. Create variations/ directory with variation folders
//   4. Add variations in variations/NN-name/ directories with index.tsx
//   5. Run: pnpm generate

import type { ElementRegistry } from '../types';

// Element imports (auto-generated)
import aichatinputElement from './AI/AIChatInput';
import chainofthoughtElement from './AI/ChainOfThought';
import chatElement from './AI/Chat';
import copypageElement from './Documentation/CopyPage';
import nextarticleElement from './Documentation/NextArticle';
import tocElement from './Documentation/TOC';
import carouselElement from './Elements/Carousel';
import ratingElement from './Elements/Rating';
import timelineElement from './Elements/Timeline';
import treeviewElement from './Elements/TreeView';
import headerElement from './foundation/Header';
import pageElement from './foundation/Page';
import sidebarElement from './foundation/Sidebar';

// Type exports (preserved)
export type { ElementMetadata, ElementVariant, ElementPackageMetadata } from '../types';
export type { ElementCategoryId, ElementCategoryDefinition } from './categories';

// Category exports (preserved)
export {
  elementCategories,
  elementCategoryMapping,
  getCategoryForElement,
  getCategoryDefinition,
  groupElementsByCategory,
  getElementsInCategory,
  getCategoriesWithElements,
} from './categories';

// Package exports
export {
  elementPackages,
  getPackageById,
  getAllPackages,
  getElementsInPackage,
  getPackageForElement,
} from './packages';

// Registry (auto-generated)
export const elementRegistry: ElementRegistry = {
  [aichatinputElement.id]: aichatinputElement,
  [chainofthoughtElement.id]: chainofthoughtElement,
  [chatElement.id]: chatElement,
  [copypageElement.id]: copypageElement,
  [nextarticleElement.id]: nextarticleElement,
  [tocElement.id]: tocElement,
  [carouselElement.id]: carouselElement,
  [ratingElement.id]: ratingElement,
  [timelineElement.id]: timelineElement,
  [treeviewElement.id]: treeviewElement,
  [headerElement.id]: headerElement,
  [pageElement.id]: pageElement,
  [sidebarElement.id]: sidebarElement,
};

// Helper functions (preserved)
export const elementsList = Object.values(elementRegistry);

export const getElementById = (id: string) => elementRegistry[id];

export const getElementsByCategory = (category: string) =>
  elementsList.filter((el) => el.category === category);

export const getElementsByTag = (tag: string) =>
  elementsList.filter((el) => el.tags.includes(tag));

export const searchElements = (query: string) => {
  const lowerQuery = query.toLowerCase();
  return elementsList.filter(
    (el) =>
      el.name.toLowerCase().includes(lowerQuery) ||
      el.description.toLowerCase().includes(lowerQuery) ||
      el.tags.some((tag) => tag.toLowerCase().includes(lowerQuery))
  );
};

export const getAllCategories = () => {
  const categories = new Set<string>();
  elementsList.forEach((el) => categories.add(el.category));
  return Array.from(categories).sort();
};

export const getAllTags = () => {
  const tags = new Set<string>();
  elementsList.forEach((el) => el.tags.forEach((tag) => tags.add(tag)));
  return Array.from(tags).sort();
};
