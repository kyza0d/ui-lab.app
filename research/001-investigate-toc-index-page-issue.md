# TOC Index Page Issue Investigation

## Executive Summary

The Table of Contents (TOC) fails to appear on initial page load for index pages (`/docs`, `/cli`, `/design-system`, `/agents-mcps`) and potentially some section-level routes due to a fundamental mismatch between how `useSelectedLayoutSegments()` extracts route segments and how the flat `tocRegistry` is structured. When visiting an index route like `/docs`, the hook returns `['docs']` as the last segment, causing a lookup for `tocRegistry['docs']` which doesn't exist (the TOC entries are stored under `tocRegistry['index']`). This results in an empty `initialItems` array being passed to `TableOfContents`, which renders `null` when no visible items are found. Dynamic routes like `/docs/styling` work correctly because "styling" exists as a key in the registry. The root cause is architectural: the flat registry design doesn't account for route-specific index pages, and `useSelectedLayoutSegments()` in a shared layout component cannot distinguish between different sections' index pages.

## Detailed Findings

### 1. Route Segment Extraction Analysis

#### How `useSelectedLayoutSegments()` Works in Shared Layouts

When `useSelectedLayoutSegments()` is called from a layout component, it returns an array of route segments from the **current layout** down to the active page. For the `DocsLayout` component (which is used by multiple sections), the returned segments depend on the section's route depth.

#### Observed Behavior for Different Routes

**Working Dynamic Routes:**
```
Route: /docs/styling
Layout: app/(main)/docs/layout.tsx (uses DocsLayout)
useSelectedLayoutSegments() returns: ['docs', 'styling']
Last segment (slug): 'styling'
Registry lookup: tocRegistry['styling']
Result: ✓ FOUND - Renders TOC with items
```

**Broken Index Route:**
```
Route: /docs (index)
Layout: app/(main)/docs/layout.tsx (uses DocsLayout)
useSelectedLayoutSegments() returns: ['docs']
Last segment (slug): 'docs'
Registry lookup: tocRegistry['docs']
Result: ✗ NOT FOUND - Returns empty array []
TableOfContents receives: initialItems = []
Renders: null (no TOC visible)
```

**Other Broken Index Routes:**
```
Route: /design-system
Layout: app/(main)/design-system/layout.tsx (uses DocsLayout)
useSelectedLayoutSegments() returns: ['design-system']
Last segment: 'design-system'
Registry lookup: tocRegistry['design-system']
Result: ✗ NOT FOUND - Returns []
```

```
Route: /cli
Layout: app/(main)/cli/layout.tsx (uses DocsLayout)
useSelectedLayoutSegments() returns: ['cli']
Last segment: 'cli'
Registry lookup: tocRegistry['cli']
Result: ✗ NOT FOUND - Registry doesn't even contain CLI docs
```

```
Route: /agents-mcps
Layout: app/(main)/agents-mcps/layout.tsx (uses DocsLayout)
useSelectedLayoutSegments() returns: ['agents-mcps']
Last segment: 'agents-mcps'
Registry lookup: tocRegistry['agents-mcps']
Result: ✗ NOT FOUND - Registry doesn't contain agents-mcps docs
```

#### Key Finding
The section name ("docs", "design-system", "cli", "agents-mcps") is **never** a key in the registry. The registry only contains keys for **individual document slugs** within those sections.

---

### 2. TOC Registry Structure Analysis

#### Current Registry Coverage

The `tocRegistry` is generated by `apps/site/scripts/generate-toc-registry.mjs`, which processes:
1. `content/docs` directory
2. `content/design-system` directory

**Notably Missing:**
- `content/cli` directory (despite existing and having documentation)
- `content/agents-mcps` directory (despite existing and having documentation)

#### Registry Keys by Section

**From content/docs:**
- "best-practices"
- "cli-guide" (confusingly named - this is a doc about CLI, stored in docs/)
- "dark-mode"
- "form-validation"
- "index"
- "installation"
- "modal-dialog"
- "styling"

**From content/design-system:**
- "accessibility"
- "colors"
- "component-guidelines"
- "spacing"
- "tokens"
- "typography"
- "variables"
- "index" (overwrites the "index" from docs!)

#### Critical Problem: Index Key Collision

Both `content/docs/index.mdx` and `content/design-system/index.mdx` generate an "index" entry in the registry. The file processed **last** (design-system) overwrites the previous one. This means:
- `tocRegistry['index']` contains TOC items from **design-system/index.mdx** only
- `tocRegistry['index']` does **not** contain TOC items from docs/index.mdx
- CLI index docs are missing entirely
- Agents/MCPs index docs are missing entirely

#### Registry Structure Visualization

```typescript
tocRegistry = {
  // From content/docs
  "best-practices": [...],
  "cli-guide": [...],
  "dark-mode": [...],
  "form-validation": [...],
  "index": [...],  // From docs/index.mdx
  "installation": [...],
  "modal-dialog": [...],
  "styling": [...],

  // From content/design-system
  "accessibility": [...],
  "colors": [...],
  "component-guidelines": [...],
  "spacing": [...],
  "tokens": [...],
  "typography": [...],
  "variables": [...],
  "index": [...],  // OVERWRITES docs/index!

  // Missing entirely:
  // - Any CLI docs (cli/, agents.mdx, best-practices.mdx, etc.)
  // - Any Agents/MCPs docs
}
```

---

### 3. TableOfContents Component Analysis

#### Initialization Logic

```typescript
export function TableOfContents({ items: initialItems }: TableOfContentsProps) {
  const [visibleItems, setVisibleItems] = useState<TableOfContentsItem[]>(initialItems);
  // ...
  const filterVisibleHeadings = useCallback(() => {
    const registryIds = new Set(initialItems.map(item => item.id));
    const visible: TableOfContentsItem[] = [];

    // Check if registry items have visible DOM elements
    for (const item of initialItems) {
      const element = document.getElementById(item.id);
      if (element && (element as HTMLElement).offsetParent !== null) {
        visible.push(item);
      }
    }

    // Discover any DOM headings not in the registry
    document.querySelectorAll('h2[id], h3[id], h4[id], h5[id], h6[id]').forEach(heading => {
      const id = heading.getAttribute('id')!;
      const htmlElement = heading as HTMLElement;
      if (htmlElement.offsetParent === null) return;

      domHeadings.add(id);
      if (!registryIds.has(id)) {
        const level = parseInt(heading.tagName[1], 10);
        visible.push({
          id,
          title: heading.textContent || '',
          level
        });
      }
    });

    setVisibleItems(visible);
  }, [initialItems]);

  useEffect(() => {
    filterVisibleHeadings();
    // ... mutation observer setup
  }, [filterVisibleHeadings, debouncedFilter]);

  // Critical: Return null if no items found
  if (visibleItems.length === 0) return null;
```

#### Behavior with Empty initialItems

1. **On First Render:**
   - `initialItems` = `[]` (from `tocRegistry['docs']` lookup failure)
   - `visibleItems` = `[]`
   - `filterVisibleHeadings()` is called in useEffect
   - The function iterates over `initialItems` (which is empty), skips the registry check
   - Discovers DOM headings via `querySelectorAll()`
   - If the page is still rendering or if there's a timing issue, DOM headings might not be discovered yet
   - `setVisibleItems([])` is called
   - Component returns `null`

2. **Key Timing Issue:**
   - The `filterVisibleHeadings()` runs synchronously after component mount
   - But MDX content rendering via `MDXRemote` is asynchronous
   - If headings aren't in the DOM yet, they won't be discovered
   - The component renders `null` before headings are available

3. **Why Dynamic Routes Work:**
   - They have `initialItems` populated (registry lookup succeeds)
   - Even if DOM discovery timing is off, `visibleItems` starts with pre-populated items
   - As long as one item exists, component doesn't return null
   - DOM discovery with mutation observer eventually adds more items

#### Root Cause Mechanism

The component relies on a **fallback to DOM discovery** when `initialItems` is empty. However, this fallback has timing issues:
- Empty `initialItems` means `visibleItems` starts empty
- `if (visibleItems.length === 0) return null` on line 169 returns before DOM discovery completes
- The mutation observer detects changes, but the component has already rendered null

---

### 4. Root Cause Analysis: Why Index/Nested Pages Fail

#### The Complete Failure Chain

```
1. User navigates to /docs (index page)
   ↓
2. DocsLayout component mounts
   ↓
3. useSelectedLayoutSegments() returns ['docs']
   ↓
4. Last segment extracted: 'docs'
   ↓
5. tocRegistry['docs'] lookup → undefined (not in registry)
   ↓
6. useMemo returns [] (empty array)
   ↓
7. TableOfContents receives initialItems = []
   ↓
8. visibleItems initializes as []
   ↓
9. useEffect calls filterVisibleHeadings() synchronously
   ↓
10. At this point, MDX content hasn't rendered yet
    ↓
11. querySelectorAll() finds no h2/h3/h4 elements
    ↓
12. setVisibleItems([]) is called
    ↓
13. if (visibleItems.length === 0) return null
    ↓
14. TableOfContents returns null
    ↓
15. ✗ TOC doesn't render
```

#### Why This Doesn't Happen with Dynamic Routes

For `/docs/styling`:
```
1. useSelectedLayoutSegments() returns ['docs', 'styling']
2. Last segment: 'styling'
3. tocRegistry['styling'] → FOUND (array with items)
4. TableOfContents receives initialItems = [{ id: "...", title: "...", level: 2 }, ...]
5. visibleItems initializes with these items
6. Even if DOM discovery timing is off, visibleItems.length > 0
7. Component doesn't return null
8. ✓ TOC renders
```

#### Why CLI and Agents/MCPs Completely Fail

The TOC registry generator (`generate-toc-registry.mjs`) only processes:
- `content/docs`
- `content/design-system`

It does NOT process:
- `content/cli`
- `content/agents-mcps`

Therefore, **no CLI or Agents/MCPs documents have TOC entries at all**, even for their dynamic routes.

Files like `content/cli/cli-guide.mdx` are completely missing from the registry, so:
- `/cli/cli-guide` tries to lookup `tocRegistry['cli-guide']` → **NOT FOUND**
- `/cli` tries to lookup `tocRegistry['cli']` → **NOT FOUND**

---

### 5. Next.js 16 Best Practices & Patterns

#### Official Next.js Guidance on Route-Aware Components

According to Next.js 16 documentation on `useSelectedLayoutSegments()`:

> `useSelectedLayoutSegments()` is a client-side hook that returns an array of the active segments **from the layout it's called in down to the leaf segment**.

Key points:
- It returns segments relative to the current layout
- It's meant for dynamic styling, conditionally rendering UI based on current route
- It's NOT meant to be a source of truth for route-based lookups in shared components

#### Problem with Shared Layouts

Using `useSelectedLayoutSegments()` in a **shared layout** (used by multiple sections) creates ambiguity:
- The hook can't distinguish between `/docs`, `/cli`, `/design-system` sections
- All return different last segments but are handled by the same component
- A shared layout needs context about *which section* it's in, not just the active segment

#### Recommended Next.js 16 Patterns

**Pattern 1: Prop-Based Configuration**
- Parent layout passes section metadata as props
- Child component uses props instead of hook
- Eliminates reliance on segment extraction

**Pattern 2: Parallel Routes (Slots)**
- Use `@sidebar` and `@content` parallel routes
- Each slot gets different content per section
- More structured than shared layouts

**Pattern 3: Layout Segment Configuration**
- Use metadata or route configuration files
- Static mapping of sections to TOC data
- Accessed via context or layout props

**Pattern 4: Segment Params vs Layout Segments**
- For pages with `[slug]` parameters, use `params` from page component
- Pass slug up to layout via context or provider
- More reliable than deriving from segments

#### What Works in Next.js 16

- `useSelectedLayoutSegments()` works reliably for extracting segments
- It correctly returns different segments for different routes
- The issue is **using it for a lookup in a flat registry from a shared layout**

---

### 6. Recommended Solutions

#### Option A: Prop-Based Section Context (Recommended)

**Approach:** Pass section name as prop from root layout

```typescript
// app/(main)/layout.tsx
export default function MainLayout({ children }: { children: React.ReactNode }) {
  return (
    <DocsLayoutProvider section={undefined}>
      {children}
    </DocsLayoutProvider>
  );
}

// app/(main)/docs/layout.tsx
import { DocsLayout } from "@/features/docs";

export default function DocsSection({ children }: { children: React.ReactNode }) {
  return (
    <DocsLayoutProvider section="docs">
      <DocsLayout section="docs">
        {children}
      </DocsLayout>
    </DocsLayoutProvider>
  );
}

// Modified DocsLayout component
export function DocsLayout({
  children,
  section
}: DocsLayoutProps & { section: 'docs' | 'cli' | 'design-system' | 'agents-mcps' }) {
  const segments = useSelectedLayoutSegments();

  const tocItems = useMemo(() => {
    // For index pages, look up section-specific index
    const slug = segments.length === 1 ? `${section}-index` : segments[segments.length - 1];
    return getTocRegistry(section)[slug] || [];
  }, [segments, section]);
}
```

**Pros:**
- Eliminates reliance on `useSelectedLayoutSegments()` for critical logic
- Allows section-specific TOC registries
- Clean and type-safe
- No breaking changes to page components

**Cons:**
- Requires updating all section layouts
- Adds prop drilling (mitigated by context)

#### Option B: Section-Specific Registries

**Approach:** Generate separate TOC registries per section

```typescript
// Generated files
export const tocRegistry = {
  docs: { "best-practices": [...], "styling": [...], "index": [...] },
  cli: { "cli-guide": [...], "index": [...] },
  "design-system": { "colors": [...], "spacing": [...], "index": [...] },
  "agents-mcps": { "getting-started": [...], "index": [...] },
};

// DocsLayout
export function DocsLayout({ children }: DocsLayoutProps) {
  const segments = useSelectedLayoutSegments();
  const section = segments[0]; // First segment is always section name

  const tocItems = useMemo(() => {
    const slug = segments[segments.length - 1] || 'index';
    return tocRegistry[section]?.[slug] || [];
  }, [segments]);
}
```

**Pros:**
- Solves registry collision problem
- Handles all sections uniformly
- Only requires updating registry generation

**Cons:**
- Assumes first segment is always section (breaks if layout hierarchy changes)
- Still relies on segment extraction which is fragile
- Requires CLI and agents-mcps to be added to generator

#### Option C: DOM-Discovery-First Approach

**Approach:** Rely entirely on DOM heading discovery, not registry

```typescript
// Remove tocRegistry lookup entirely
export function DocsLayout({ children }: DocsLayoutProps) {
  // No segment-based lookup
  return (
    <div className="...">
      <Sidebar />
      <div id="docs">{children}</div>
      <TableOfContents items={[]} /> {/* Start with empty */}
    </div>
  );
}

// Enhanced TableOfContents
export function TableOfContents() {
  const [visibleItems, setVisibleItems] = useState<TableOfContentsItem[]>([]);

  useEffect(() => {
    // Aggressively discover headings from DOM
    const observer = new MutationObserver(() => {
      discoverHeadings();
    });
    observer.observe(document.getElementById('docs')!, {
      childList: true,
      subtree: true,
    });

    // Initial discovery
    setTimeout(() => discoverHeadings(), 100);
  }, []);
}
```

**Pros:**
- Eliminates registry and segment lookup complexity
- Works for all sections automatically
- No build-time generation needed

**Cons:**
- Loses pre-generated, optimized TOC data
- Fully client-side, slight initial performance impact
- No guarantee headings follow consistent structure across sections

---

### 7. Implementation Notes

#### Files That Need Changes

**For Option A:**
- `/apps/site/src/features/docs/components/docs-layout.tsx` - Add section prop
- `/apps/site/src/app/(main)/docs/layout.tsx` - Pass section prop
- `/apps/site/src/app/(main)/cli/layout.tsx` - Pass section prop
- `/apps/site/src/app/(main)/design-system/layout.tsx` - Pass section prop
- `/apps/site/src/app/(main)/agents-mcps/layout.tsx` - Pass section prop

**For Option B:**
- `/apps/site/scripts/generate-toc-registry.mjs` - Update to process all domains
- `/apps/site/src/features/docs/lib/generated-toc-registry.ts` - New structure
- `/apps/site/src/features/docs/components/docs-layout.tsx` - Update lookup logic

**For Option C:**
- `/apps/site/src/features/docs/components/table-of-contents.tsx` - Remove null return, improve discovery
- `/apps/site/src/features/docs/components/docs-layout.tsx` - Remove registry lookup

#### Complexity Assessment

- **Option A:** Moderate - requires updating 5 layout files, adding context provider
- **Option B:** Low-Moderate - mainly script updates, minimal component changes
- **Option C:** Low - table-of-contents changes only, no layout changes

#### Risks & Breaking Changes

- **Option A:** None - additive props only
- **Option B:** Minimal - registry structure change but same API
- **Option C:** Potential - requires ensuring all pages have proper heading IDs and structures

#### Testing Considerations

- Verify TOC appears on first load for all index pages
- Test dynamic routes still work
- Test TOC updates when navigating between routes
- Test mutation observer properly handles async MDX rendering
- Verify headings are discovered in correct order and hierarchy
